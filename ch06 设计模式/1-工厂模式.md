# 工厂模式

我们从最简单也是最常见的模式：**工厂模式**出发。

## 创建对象的通用接口

之前已经强调过，在JavaScript的编程范式中，会倾向于使用纯面向对象的设计，这样可以保证简单、可用性和**最小界面**原则。在创建新对象时尤其如此。实际上从某些方面来说，触发工厂方法比直接用`new`操作符或者`Object.create()`从原型创建新对象更方便也更灵活。

首先也是最重要的，工厂允许我们从其实现中分离出对象创建；尤其是工厂将对象创建包裹起来，给了我们实现的它的灵活性和控制力。在工厂内部，我们既可以使用原型和`new`操作符，也可以使用`Object.create()`或者是基于某种特定的条件规则返回不同的实例。工厂的调用者完全不用知道实例是怎样创建出来的。实际上，如果使用了`new`，就把我们的代码和某种特定的对象创建方式绑定起来了，但是在JavaScript中，我们可以有更多的灵活性，几乎不会增加工作量。下面举一个创建`Image`对象的实例：

```
function createImage(name) {
    return new Image(name);
}
const image = createImage('photo.jpeg');
```

`createImage()`工厂虽然看起来不必要；为啥不直接使用`new`操作符来实例化`Image`类呢？就像下面这样：

```
const image = new Image(name);
```
正如之前提到过的，使用`new`关键字就把我们的代码和特定类型的对象关联起来了； 在前面的例子中，这个特定的类型便是`Image`。但是，工厂模式会给我们更多的灵活性；假如我们想重构`Image`类，把它分离到更小的类中去，支持每一种图片格式。如果我们已经通过工厂来创建图片，则可以简单地以如下方式重写工厂，而无需修改现有的代码：

```
function createImage(name) { 
  if(name.match(/.jpeg$/)) { 
    return new JpegImage(name); 
  } else if(name.match(/.gif$/)) { 
    return new GifImage(name); 
  } else if(name.match(/.png$/)) { 
    return new PngImage(name); 
  } else { 
    throw new Exception('Unsupported format'); 
  } 
} 
```
工厂模式也可以实现不暴露它创建的对象的构造器的目的，防止其被拓展或者修改（还记得最小界面原则吗？）。在Node.js中，可以通过只导出工厂的方式实现，也保证了每个构造器的私有性。


## 一种强制封装的机制

多亏了闭包，工厂也可以用来实现封装机制。

> **封装**是指控制对象内部细节可见性的技术，可以防止外部代码直接修改它们。和对象的交互只能通过它的公共接口，隔绝了外部代码修改对象内部实现的可能性。这项实践也称为**信息隐藏**。封装也是面向对象设计的一项基本原则，另外几项基本原则是继承、多态和抽象。

我们都知道，在JavaScript中没有**访问修饰符**(比如，我们不能声明一个私有变量。)，因此，实现封装的唯一方式是通过函数作用域和闭包。工厂模式使实现私有变量称为可能；如下面的例子所示：

```
function createPerson(name) { 
  const privateProperties = {}; 
 
  const person = { 
    setName: name => { 
      if(!name) throw new Error('A person must have a name'); 
      privateProperties.name = name; 
    }, 
    getName: () => { 
      return privateProperties.name; 
    } 
  }; 
 
  person.setName(name); 
  return person; 
} 
```

在上面的例子中，我们使用闭包创建了两个对象，一个`person`对象是公共接口，会被工厂返回，一组`privateProperties`无法从外部访问到，只能通过`person`对象提供的接口操作。比如，在前面的代码中，我们要确保`person`的`name`属性永远不能为空；如果`name`仅仅是`person`对象的属性，就不可能实现这个目标。

> 工厂方法只是创建私有成员的技术之一；事实上，有以下其它几种方式：
> 在构造器中定义私有变量（[被Douglas Crockford推荐的方式](http://javascript.crockford.com/private.html)）。
> 使用约定，比如，在属性名字前面加一个下划线“_”或者是美元符号"$"（这样并没有从技术上阻止某个成员从外部被访问到。）
> 使用ES2015的*[WeakMaps](http://fitzgeraldnick.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html)*
> 针对这个主题，Mozilla发表过一篇非常完整的[文章](https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Contributor_s_Guide/Private_Properties)。

## 构建一个简单的性能工具

现在，开始一个使用工厂模式的完整例子。构造一个简单的`代码性能工具`，一个拥有如下两个属性的对象：

> 一个`start()`方法，触发度量会话的启动。
>一个`end()`方法，终止会话并把执行时间打印到控制台上。

先创建一个叫做`profiler.js`的文件，内容如下：

```
class Profiler { 
  constructor(label) { 
    this.label = label; 
    this.lastTime = null; 
  } 
 
  start() { 
    this.lastTime = process.hrtime(); 
  } 
 
  end() { 
    const diff = process.hrtime(this.lastTime); 
    console.log( 
      `Timer "${this.label}" took ${diff[0]} seconds and ${diff[1]} 
        nanoseconds.` 
    ); 
  } 
} 
```
前面的类并没有什么特别的；只是在`start()`触发时使用默认的高精度计时器来保存当前时间，在`end()`执行时，计算过去了多长时间，将结果打印在控制台上。

现在，如果我们在实际应用中使用这个性能工具来计算不同线程的执行时间，可以想象，将会有大量的日志生成到控制台，尤其是在生产环境中。我们会想到把程序改成将性能信息指向到另外一个源中，比如数据库，或者是在生产模式禁用掉这个工具。这样一来，如果我们当时是用`new`操作符来完成`Profiler`对象的实例化操作，将需要在客户代码或者`Profiler`对象内部增加一些逻辑，来适应逻辑的变化。我们可以改用工厂来抽象`Profiler`对象的创建，因此基于程序是运行在生产环境还是开发环境，都可以返回一个完全可以工作的`Profiler`对象，或者是返回一个假对象，拥有同样的接口，但是方法是空的。 接下来在`profiler.js`模块中实现这个想法，改变之前导出`Profiler`构造器的方式，我们只需导出一个`Profiler`构造器，只会导出一个函数，即工厂。代码如下：

```
module.exports = function(label) { 
  if(process.env.NODE_ENV === 'development') { 
    return new Profiler(label);                       //[1] 
  } else if(process.env.NODE_ENV === 'production') { 
    return {                                          //[2] 
      start: function() {}, 
      end: function() {} 
    } 
  } else { 
    throw new Error('Must set NODE_ENV'); 
  } 
}; 
```
上面创建的工厂函数把`Profiler`对象的创建从实现中抽象出来了。

> 如果程序以开发模式运行，返回一个新的，功能完整的`Profiler`对象。
> 否则，程序以生产模式运行，返回一个假对象，其`start()`和`stop()`方法均为空函数。

有一个好的特性值得一提，多亏了JavaScript的动态类型，我们可以根据不同的情况，返回使用`new`操作符实例化的对象或者是简单的对象字面量（也称为**[鸭子类型](https://en.wikipedia.org/wiki/Duck_typing)**）。我们的工厂完美地完成了它的使命；我们可以使用我们喜欢的任意方式在工厂函数内部创建对象，并且可以执行更多的实例化操作步骤或者基于特定的条件返回对象，与此同时，可以将这些细节和调用工厂的代码隔离开来。这个简单模式的作用显而易见。

现在可以用一下这个性能测量器了；下面是上面的工厂函数的一个可能的用例：

```
const profiler = require('./profiler'); 
 
function getRandomArray(len) { 
  const p = profiler('Generating a ' + len + ' items long array'); 
  p.start(); 
  const arr = []; 
  for(let i = 0; i < len; i++) { 
    arr.push(Math.random()); 
  } 
  p.end(); 
} 
 
getRandomArray(1e6); 
console.log('Done'); 
```

`p`变量包含`Profiler`对象的实例，但这里无需知道它是如何被创建出来的以及其内部实现。

如果将前面的代码包含到`profilerTest.js`中，便可验证这个假设。在度量打开时运行这个程序，执行下面的命令：`export NODE_ENV=development; node profilerTest` 。前面的命令开启了真正的度量，并把性能信息打印到了控制台上。运行下面的命令来测试假的度量： `export NODE_ENＶ=production; node profilerTest`。

上面的例子仅仅是工厂函数模式的一个简单应用，但它清晰地展示了分离对象创建和逻辑实现的巨大优势。



## 可组装的工厂方法

## 工厂模式实例