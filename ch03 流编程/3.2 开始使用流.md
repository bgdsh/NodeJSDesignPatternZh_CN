# 开始使用流
在前面一节，我们学到了流的作用非常大，除此之外，流从核心模块开始，遍布于整个Node.js。
比如，`fs`模块用 `createReadStream()` 来从文件读取，用`createWriteStream()`来写入文件，`http`请求和响应对象也是流，`zlib`使我们可以以流的方式来压缩、解压数据。

现在我们明白了为什么流如此重要，接下来从头开始，深入地探索流的内涵。
## 剖析流
在Node.js中，每种流都是下面四种抽象类型的一种实现，这四种类型都可以在`stream`核心模块中见到：

* `stream.Readable`
* `steam.Writable`
* `stream.Duplex`
* `stream.Transform`

每种流类型都是`EventEmitter`的一个实例。流可以产生许多种类型的事件，比如当`Readable`流读取完毕之后，会发出`end`事件，当出错时，会发出`error`事件。

> 需要注意的一点是，本章展示的例子中，会适当地进行错误处理。但是在实际生产中，在流上注册一个`error`监听事件。

流的弹性非常大的原因之一是它们不仅可以处理字节数据，而且可以更加实用地处理几乎任何JavaScript值；事实上，流可以支持两种类型的操作：

* **字节模式**：在这种模式下，数据会变成小块的流，比如缓存或者是字符串。
* **对象模式**： 在这种模式下，流数据是一列对象（这个对象可以是大部分的JavaScript值）。

这两种操作模式使我们可以不光在I/O中使用流，还可以把它作为以函数式风格构建处理单元的工具，本章后续部分会做出相应介绍。

> 在本章中，我们主要讨论为大家所熟知的版本2，它是在Node.js 0.10版引入的。如果想了解就版接口的细节，请参考Node.js的官方博客 http://blog.nodejs.org/2012/12/20/streams2 。
## 可读的流
可读流为数据的来源；在Node.js中，它基于`stream`模块中的`Readable`抽象类来实现。
### 从流读取
从`Readable`模式接收数据有两种方式：流式和非流式。
#### 非流式
从`Readable`流读取的默认模式是为表征新数据可读的事件`readable`绑定一个监听器。那么，在循环中，读取所有数据直到缓存清空。可以通过`read()`方法来实现，这个方法同步地从内部缓存读取数据并返回一个`Buffer` 或 `String`对象，表征一个数据块。`read()`函数的签名如下：

```
readable.read([size])
```
使用这种方法，数据可以简单地从流按需读取。

为展示其工作模式，我们创建一个新的模块叫做`readStein.js`，实现了一个从标准输入（一种`Readable`流），并把所有的内容都返回到标准输出：

```
process.stdin
  .on('readable', function() {
    var chunk;
    console.log('New data available');
    while((chunk = process.stdin.read()) !== null) {
      console.log(
        'Chunk read: (' + chunk.length + ') "' +
        chunk.toString() + '"'
      );
    }
  })
  .on('end', function() {
    process.stdout.write('End of stream');
  });
```
`read()`方法是一个同步操作，从`Readable`流拉取数据块。如果流以字节模式运行，返回的数据块默认是一个`Buffer`对象。

> 在一个以字节模式运行的`Readable`流中，可以通过调用流的`setEncoding(encoding)`改为读取字符串，并提供一个有效的编码格式（比如：`utf8`）。

数据只能在`readable`监听器中读取，当有新的数据可读时，监听器会被触发。如果在内部缓存中没有数据可读，`read()`方法将返回`null`；此时，只能等待另一个`readable`事件被触发，告诉我们可以再次读取；或者是在流的最后，等待触发`end`事件。当流以字节模式运行时，我们也可以通过给`read()`方法传递一个`size`参数来读取特定长度的数据。这在实现网络协议或者解析特定的数据格式时十分有用。

现在我们可以运行`readStdin`模块并进行实验。在控制台输入一些字符，按下回车键，观察返回到标准输出的结果。为了在结束流并且生成一个优雅的`end`事件，我们需要插入一个`EOF`（文件结束符）（Windows使用*Ctrl+Z*，Linux使用*Ctrl+D*）。

也可以尝试把我们的程序和其他进程连接起来；使用管道操作符(|)，它会把一个程序的标准输出传递给下一个。比如，可以运行如下命令：

```
cat <文件路径> | node readStdin
```
这个例子有力地说明了流模式是一个通用的接口，它使我们的程序可以和别的预言通信。
#### 流式
从流读取的另一个方法是给它附加一个`data`事件；这将会把流转换为`流`模式，数据不再由`read()`拉取，而是一有数据，就被推送到`data`监听器上。比如，使用流模式后，前面的`readStdin`应用将代码如下：

```
process.stdin
  .on('data', function(chunk) {
    console.log('New data available');
    console.log(
      'Chunk read: (' + chunk.length + ')" ' +
      chunk.toString() + '"'
    );
  })
  .on('end', function() {
    process.stdout.write('End of stream');
  });
```
流模式继承了旧版的`steam`接口（也被称为*Streams1*），对数据处理的灵活性比较差。*Streams2*接口引入之后，流模式不再是默认的工作模式；为了开启流模式，可以给`data`事件附加一个监听器或者是直接触发`resume()`方法。为了暂时阻止流触发`data`事件，我们可以使用`pause()`方法，它会使所有进入的数据都被缓存在内部缓存中。

> 调用 `pause()`不会导致流返回非流模式。

### 实现可读流
既然我们知道了如何从流读取，下一步就是学习如何实现一个新的`Readable`流。为了实现这个目标，有必要创建一个继承自`steam.Readable`原型的类。具体的类实现中，必须提供`_read()`方法，它的签名如下：

```
readable._read(size)
```
在`Readable`类内部会调用`_read()`方法，它会使用`push()`依次填充内部缓冲区：

```
readable.push(chunk)
```
> 请牢记，`read()`是一个被流消费者调用的方法，而`_read()`是一个被流的子类实现的方法，无需直接调用。下划线通常表示这个方法不是公开的，无需直接调用。

为展示如何实现新的`Readable`流，我们可以实现一个生成随机字符串的流。创建一个叫做`randomStream.js`的模块，它将包含字符串生成器的代码。文件最上面，引入依赖：

```
var stream = require('stream');
var util = require('util');
var chance = require('chance').Chance();
```
没什么特别的，除了加载了一个叫做`chance`（ https://npmjs.org/package/chance ）的模块，它是一个可以生成任意种类的随机值的库，范围涵盖数字、字符串再到整个句子。

下一步是创建一个新的类叫做`RandomStream`，它指定了`stream.Readable`作为其父类：

```
function RandomStream(options) {
  stream.Readable.call(this, options);
}
util.inherits(RandomStream, stream.Readable);
```
在前面的代码中，调用父类的构造器来实现它的初始状态，传递`options`参数作为输入条件。通过`options`传入的参数如下：

* `encoding`参数用于把`Buffers`转换为`Strings`，其默认值是`null`。
* 一个开启对象模式的标识（`objectMode`默认为`false`）。
* 存储在内部缓冲区中的数据量上限。超过这个限制之后，无法继续从源读取数据（`highWaterMark`默认值是16KB）。

现在，既然新的`RandomStream`构造器已经完成了，接下来可以实现`_read()`方法了：

```
RandomStream.prototype._read = function(size) {
  var chunk = chance.string();         //[1]
  console.log('Pushing chunk of size:' + chunk.length);
  this.push(chunk, 'utf8');           //[2]
  if(chance.bool({likelihood: 5})) {       //[3]
    this.push(null);
  }
}
module.exports = RandomStream;
```
以下为对上述方法的解释：

1. 该方法使用`chance`生成一个随机字符串。
2. 将字符串推送到内部读取缓冲区。需要注意，既然推送的是字符串，指定编码格式的`utf8`(如果数据块只是一个字节`Buffer`对象，这样做是没意义的)。
3. 以5%的可能性随机地终止流，通过推送`null`到内部缓冲区来表示`EOF`的情况，换句话说，即为流的终结。

你也会发现，给到`_read()`的`size`参数被忽略了，因为这只是一个推荐的参数。我们可以简单地推送所有的数据，但如果要在同一次触发时推送多次，我们需要检查`push()`是否返回了`false`，这意味着内部缓冲区达到了上限`highWaterMark`，必须要停止向它增加更多的数据。

上面都是关于`RandomStream`的讨论；现在还没准备好调用它。现在创建一个新的模块`generateRandom.js`，在这里实例化一个新的`RandomStream`对象，并从中拉取数据：

```
var RandomStream = require('./randomStream');
var randomStream = new RandomStream();
randomStream.on('readable', function() {
  var chunk;
  while((chunk = randomStream.read()) !== null) {
    console.log("Chunk received: " + chunk.toString());
  }
});
```
现在可以尝试一下心得自定义流了。简单地执行`generateRandom`模块，看屏幕上输出的一组随机字符串。
## 可写流
### 写入流
### 背压
### 实现可写流
## 双向流
## 流的转换
### 实现流的转换
## 使用管道连接流
## 有用的包
### 可读流
### 流经和源


