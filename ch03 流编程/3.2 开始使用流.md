# 开始使用流
在前面一节，我们学到了流的作用非常大，除此之外，流从核心模块开始，遍布于整个Node.js。
比如，`fs`模块用 `createReadStream()` 来从文件读取，用`createWriteStream()`来写入文件，`http`请求和响应对象也是流，`zlib`使我们可以以流的方式来压缩、解压数据。

现在我们明白了为什么流如此重要，接下来从头开始，深入地探索流的内涵。
## 剖析流
在Node.js中，每种流都是下面四种抽象类型的一种实现，这四种类型都可以在`stream`核心模块中见到：

* `stream.Readable`
* `steam.Writable`
* `stream.Duplex`
* `stream.Transform`

每种流类型都是`EventEmitter`的一个实例。流可以产生许多种类型的事件，比如当`Readable`流读取完毕之后，会发出`end`事件，当出错时，会发出`error`事件。

> 需要注意的一点是，本章展示的例子中，会适当地进行错误处理。但是在实际生产中，在流上注册一个`error`监听事件。

流的弹性非常大的原因之一是它们不仅可以处理字节数据，而且可以更加实用地处理几乎任何JavaScript值；事实上，流可以支持两种类型的操作：

* **字节模式**：在这种模式下，数据会变成小块的流，比如缓存或者是字符串。
* **对象模式**： 在这种模式下，流数据是一列对象（这个对象可以是大部分的JavaScript值）。

这两种操作模式使我们可以不光在I/O中使用流，还可以把它作为以函数式风格构建处理单元的工具，本章后续部分会做出相应介绍。

> 在本章中，我们主要讨论为大家所熟知的版本2，它是在Node.js 0.10版引入的。如果想了解就版接口的细节，请参考Node.js的官方博客 http://blog.nodejs.org/2012/12/20/streams2 。
## 可读的流
可读流为数据的来源；在Node.js中，它基于`stream`模块中的`Readable`抽象类来实现。
### 从流读取
从`Readable`模式接收数据有两种方式：流式和非流式。
#### 非流式
从`Readable`流读取的默认模式是为表征新数据可读的事件`readable`绑定一个监听器。那么，在循环中，读取所有数据直到缓存清空。可以通过`read()`方法来实现，这个方法同步地从内部缓存读取数据并返回一个`Buffer` 或 `String`对象，表征一个数据块。`read()`函数的签名如下：

```
readable.read([size])
```
使用这种方法，数据可以简单地从流按需读取。

为展示其工作模式，我们创建一个新的模块叫做`readStein.js`，实现了一个从标准输入（一种`Readable`流），并把所有的内容都返回到标准输出：

```
process.stdin
  .on('readable', function() {
    var chunk;
    console.log('New data available');
    while((chunk = process.stdin.read()) !== null) {
      console.log(
        'Chunk read: (' + chunk.length + ') "' +
        chunk.toString() + '"'
      );
    }
  })
  .on('end', function() {
    process.stdout.write('End of stream');
  });
```
`read()`方法是一个同步操作，从`Readable`流拉取数据块。如果流以字节模式运行，返回的数据块默认是一个`Buffer`对象。

> 在一个以字节模式运行的`Readable`流中，可以通过调用流的`setEncoding(encoding)`改为读取字符串，并提供一个有效的编码格式（比如：`utf8`）。

数据只能在`readable`监听器中读取，当有新的数据可读时，监听器会被触发。如果在内部缓存中没有数据可读，`read()`方法将返回`null`；此时，只能等待另一个`readable`事件被触发，告诉我们可以再次读取；或者是在流的最后，等待触发`end`事件。当流以字节模式运行时，我们也可以通过给`read()`方法传递一个`size`参数来读取特定长度的数据。这在实现网络协议或者解析特定的数据格式时十分有用。

现在我们可以运行`readStdin`模块并进行实验。在控制台输入一些字符，按下回车键，观察返回到标准输出的结果。为了在结束流并且生成一个优雅的`end`事件，我们需要插入一个`EOF`（文件结束符）（Windows使用*Ctrl+Z*，Linux使用*Ctrl+D*）。

也可以尝试把我们的程序和其他进程连接起来；使用管道操作符(|)，它会把一个程序的标准输出传递给下一个。比如，可以运行如下命令：

```
cat <文件路径> | node readStdin
```
这个例子有力地说明了流模式是一个通用的接口，它使我们的程序可以和别的预言通信。
#### 流式
从流读取的另一个方法是给它附加一个`data`事件；这将会把流转换为`流`模式，数据不再由`read()`拉取，而是一有数据，就被推送到`data`监听器上。比如，使用流模式后，前面的`readStdin`应用将代码如下：

```
process.stdin
  .on('data', function(chunk) {
    console.log('New data available');
    console.log(
      'Chunk read: (' + chunk.length + ')" ' +
      chunk.toString() + '"'
    );
  })
  .on('end', function() {
    process.stdout.write('End of stream');
  });
```
流模式继承了旧版的`steam`接口（也被称为*Streams1*），对数据处理的灵活性比较差。*Streams2*接口引入之后，流模式不再是默认的工作模式；为了开启流模式，可以给`data`事件附加一个监听器或者是直接触发`resume()`方法。为了暂时阻止流触发`data`事件，我们可以使用`pause()`方法，它会使所有进入的数据都被缓存在内部缓存中。

> 调用 `pause()`不会导致流返回非流模式。

### 实现可读流
## 可写流
### 写入流
### 背压
### 实现可写流
## 双工流
## 流的转换
### 实现流的转换
## 使用管道连接流
## 有用的包
### 可读流
### 流经和源


