# 开始使用流
在前面一节，我们学到了流的作用非常大，除此之外，流从核心模块开始，遍布于整个Node.js。
比如，`fs`模块用 `createReadStream()` 来从文件读取，用`createWriteStream()`来写入文件，`http`请求和响应对象也是流，`zlib`使我们可以以流的方式来压缩、解压数据。

现在我们明白了为什么流如此重要，接下来从头开始，深入地探索流的内涵。
## 剖析流
在Node.js中，每种流都是下面四种抽象类型的一种实现，这四种类型都可以在`stream`核心模块中见到：

* `stream.Readable`
* `steam.Writable`
* `stream.Duplex`
* `stream.Transform`

每种流类型都是`EventEmitter`的一个实例。流可以产生许多种类型的事件，比如当`Readable`流读取完毕之后，会发出`end`事件，当出错时，会发出`error`事件。

> 需要注意的一点是，本章展示的例子中，会适当地进行错误处理。但是在实际生产中，在流上注册一个`error`监听事件。

流的弹性非常大的原因之一是它们不仅可以处理字节数据，而且可以更加实用地处理几乎任何JavaScript值；事实上，流可以支持两种类型的操作：

* **字节模式**：在这种模式下，数据会变成小块的流，比如缓存或者是字符串。
* **对象模式**： 在这种模式下，流数据是一列对象（这个对象可以是大部分的JavaScript值）。

这两种操作模式使我们可以不光在I/O中使用流，还可以把它作为以函数式风格构建处理单元的工具，本章后续部分会做出相应介绍。

> 在本章中，我们主要讨论为大家所熟知的版本2，它是在Node.js 0.10版引入的。如果想了解就版接口的细节，请参考Node.js的官方博客 http://blog.nodejs.org/2012/12/20/streams2 。
## 可读的流
### 从流读取
#### 无流程模式
#### 有流程模式
### 实现可读流
## 可写流
### 写入流
### 背压
### 实现可写流
## 双工流
## 流的转换
### 实现流的转换
## 使用管道连接流
## 有用的包
### 可读流
### 流经和源


