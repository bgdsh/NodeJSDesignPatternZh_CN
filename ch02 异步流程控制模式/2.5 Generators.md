# Generators
ES6规范引入了另一个机制，用于简化Node.js应用的异步流程控制。我们说的是**Generators**，也被称为半协程。它是子路径的生成器，可以有不同的入口。在一个普通的函数中，只能拥有一个入口，即触发函数本身。Generator和函数类似，但此外它可以挂起（使用**yield**声明），过一会之后还能恢复。在实现遍历器时Generator非常有用，这个可能会听起来耳熟，因为前面章节已经学到了怎样使用遍历器来实现非常有用的异步流程控制模式，诸如顺序执行和限制数量的并行执行。
> 在Node.js中，generator在0.11版本中就包含进来了，但在写作此书时，这个特性依旧不是默认开启的，需要带上`--harmony`或者`--harmony-generators`参数来使生成器正常工作。如果要尝试运行本节的例子，运行如下命令确保安装了正确版本的Node.js（0.11.0或以上版本）：`node --version`。

## 基础
在探索在异步流程控制中使用generator之前，很有必要学习一些基本概念。从语法部分开始；一个生成器函数的声明是在`function`后面加上`*`（星号）：

```
function* makeGenerator() {
    //body
}
```
在`makeGenerator()`方法内部，可以使用关键字`yield`来暂停执行，并把传入的值返回给调用者：

```
function* makeGenerator() {
    yield 'Hello World';
    console.log('Re-entered');
}
```
在前面的代码中，generator产出一个字符串`Hello World`并把函数的执行暂停。当generator恢复后，执行会从`console.log('Re-entered')`开始执行。
`makeGenerator()`函数其实是一个工厂，但它被触发后，返回一个新的生成器对象：

```
var gen = makeGenerator() ;
```
生成器对象最重要的方法是`next()`，它用于启动/恢复生成器的执行并返回一个对象，格式如下：

```
{
    value: <产出的值>,
    done: <如果执行到最后则为true>
}
```
这个对象包含生成器产出的值（`value`）和一个标识来说明生成器是否已经执行完毕（`done`）。

### 一个简单的例子
举个例子，创建一个新的模块*fruitGenerator.js*，代码如下：

```
function* fruitGenerator() {
    yield 'apple';
    yield 'orange';
    return 'watermelon';
}

var newFruitGenerator = fruitGenerator();
console.log(newFruitGenerator.next());    //[1]
console.log(newFruitGenerator.next());    //[2]
console.log(newFruitGenerator.next());    //[3]
```
使用如下命令运行新的模块：

```
node --harmony-generators fruitGenerator
```
前面的代码会打印如下输出：

```
{ value: 'apple', done: false }
{ value: 'orange', done: false }
{ value: 'watermelon', done: true }
```
以下是对上面的代码做出的解释：

1. 第一次`newFruitGenerator.next()`触发时，生成器开始执行，直到它到达第一个`yield`命令，它把生成器暂停并把值`apple`返回给了调用者。
2. 第二次触发`newFruitGenerator.next()`时，生成器恢复，从第二个`yeild`开始，按次序把执行再次暂停，同时把值`orange`返回给调用者。
3. 最后一次触发`newFruitGenerator.next()`使生成器从上次的位置开始恢复执行，`return`声明终结了生成器，返回值`watermelon`,并把结果中的`done`属性设置为`true`。
### 生成器作为遍历器
为更好地理解为什么生成器对于实现遍历器是多么有用，让我们来构建一个新的模块*iteratorGenerator.js*，写下如下代码：

```
function* iteratorGenerator(arr) {
    for (var i = 0; i < arr.length; i++) {
        yield arr[i];
    }
}

var iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);
var currentItem = iterator.next();
while (!currentItem.done) {
    console.log(currentItem.value);
    currentItem = iterator.next();
}
```
使用如下命令运行代码：

```
node --harmony-generators iteratorGenerator
```
前面的程序会打印数组中的所有元素，结果如下：

```
apple
orange
watermelon
```
在这个例子中，每次调用`iterator.next()`，就会恢复生成器中的for循环，然后运行下一轮，产出数组的下一个元素。这个写法展示了怎样在多次调用之间保持生成器的状态。恢复之后，循环和所有的变量都和暂停之前一样。

### 传值给生成器
下面以学习怎样传值给生成器来结束对生成器基础功能的探索。这非常简单，只需要给`next()`提供一个参数，这个值在生成器内部将会作为`yeild`声明的返回值。
为展示这个特性，创建一个新的实例模块：

```
function* twoWayGenerator() {
    var what = yield null;
    console.log('hello ' + what);
}
var twoWay = twoWayGenerator();
twoWay.next();
twoWay.next('world');
```
当执行完毕后，前面的代码会打印`hello world`。其工作机制如下：

1. 当第一个`next()`方法被触发了，生成器到达了第一个`yield`函数，然后生成器被暂停了。
2. 当触发`next('world')`后，生成器从暂停中恢复，回到`yield`指令，但这次有一个值传回到生成器。这个值会接着赋给`what`变量。然后生成器执行`console.log()`指令并停止。

同样地，可以迫使生成器抛出一个异常。可以通过生成器的`throw`方法来实现，示例如下：

```
var twoWay = twoWayGenerator();
twoWay.next();
twoWay.throw( new Error() );
```
使用上面这个代码段，当`yield`函数返回时，`twoWayGenerator()`函数将会抛出一个异常。这和生成器内部抛出异常是类似的，这种异常可以和其它异常一样，可以被`try-catch`块捕获。

## 使用generator进行异步流程控制

### 使用co进行基于generator的流程控制

## 顺序执行

## 并行执行

## 有限的并行执行

### 生产者消费者模式

### 限制下载任务的并发

