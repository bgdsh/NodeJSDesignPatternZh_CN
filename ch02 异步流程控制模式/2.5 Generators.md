# Generators
ES6规范引入了另一个机制，用于简化Node.js应用的异步流程控制。我们说的是**Generators**，也被称为半协程。它是子路径的生成器，可以有不同的入口。在一个普通的函数中，只能拥有一个入口，即触发函数本身。Generator和函数类似，但此外它可以挂起（使用**yield**声明），过一会之后还能恢复。在实现遍历器时Generator非常有用，这个可能会听起来耳熟，因为前面章节已经学到了怎样使用遍历器来实现非常有用的异步流程控制模式，诸如顺序执行和限制数量的并行执行。
> 在Node.js中，generator在0.11版本中就包含进来了，但在写作此书时，这个特性依旧不是默认开启的，需要带上`--harmony`或者`--harmony-generators`参数来使生成器正常工作。如果要尝试运行本节的例子，运行如下命令确保安装了正确版本的Node.js（0.11.0或以上版本）：`node --version`。

## 基础
在探索在异步流程控制中使用generator之前，很有必要学习一些基本概念。从语法部分开始；一个生成器函数的声明是在`function`后面加上`*`（星号）：

```
function* makeGenerator() {
    //body
}
```
在`makeGenerator()`方法内部，可以使用关键字`yield`来暂停执行，并把传入的值返回给调用者：

```
function* makeGenerator() {
    yield 'Hello World';
    console.log('Re-entered');
}
```
在前面的代码中，generator产出一个字符串`Hello World`并把函数的执行暂停。当generator恢复后，执行会从`console.log('Re-entered')`开始执行。
`makeGenerator()`函数其实是一个工厂，但它被触发后，返回一个新的生成器对象：

```
var gen = makeGenerator() ;
```
生成器对象最重要的方法是`next()`，它用于启动/恢复生成器的执行并返回一个对象，格式如下：

```
{
    value: <产出的值>,
    done: <如果执行到最后则为true>
}
```
这个对象包含生成器产出的值（`value`）和一个标识来说明生成器是否已经执行完毕（`done`）。

### 一个简单的例子
举个例子，创建一个新的模块*fruitGenerator.js*，代码如下：

```
function* fruitGenerator() {
    yield 'apple';
    yield 'orange';
    return 'watermelon';
}

var newFruitGenerator = fruitGenerator();
console.log(newFruitGenerator.next());    //[1]
console.log(newFruitGenerator.next());    //[2]
console.log(newFruitGenerator.next());    //[3]
```
使用如下命令运行新的模块：

```
node --harmony-generators fruitGenerator
```
前面的代码会打印如下输出：

```
{ value: 'apple', done: false }
{ value: 'orange', done: false }
{ value: 'watermelon', done: true }
```
以下是对上面的代码做出的解释：

1. 第一次`newFruitGenerator.next()`触发时，生成器开始执行，直到它到达第一个`yield`命令，它把生成器暂停并把值`apple`返回给了调用者。
2. 第二次触发`newFruitGenerator.next()`时，生成器恢复，从第二个`yeild`开始，按次序把执行再次暂停，同时把值`orange`返回给调用者。
3. 最后一次触发`newFruitGenerator.next()`使生成器从上次的位置开始恢复执行，`return`声明终结了生成器，返回值`watermelon`,并把结果中的`done`属性设置为`true`。
### 生成器作为遍历器
为更好地理解为什么生成器对于实现遍历器是多么有用，让我们来构建一个新的模块*iteratorGenerator.js*，写下如下代码：

```
function* iteratorGenerator(arr) {
    for (var i = 0; i < arr.length; i++) {
        yield arr[i];
    }
}

var iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);
var currentItem = iterator.next();
while (!currentItem.done) {
    console.log(currentItem.value);
    currentItem = iterator.next();
}
```
使用如下命令运行代码：

```
node --harmony-generators iteratorGenerator
```
前面的程序会打印数组中的所有元素，结果如下：

```
apple
orange
watermelon
```
在这个例子中，每次调用`iterator.next()`，就会恢复生成器中的for循环，然后运行下一轮，产出数组的下一个元素。这个写法展示了怎样在多次调用之间保持生成器的状态。恢复之后，循环和所有的变量都和暂停之前一样。

### 传值给生成器
下面以学习怎样传值给生成器来结束对生成器基础功能的探索。这非常简单，只需要给`next()`提供一个参数，这个值在生成器内部将会作为`yeild`声明的返回值。
为展示这个特性，创建一个新的实例模块：

```
function* twoWayGenerator() {
    var what = yield null;
    console.log('hello ' + what);
}
var twoWay = twoWayGenerator();
twoWay.next();
twoWay.next('world');
```
当执行完毕后，前面的代码会打印`hello world`。其工作机制如下：

1. 当第一个`next()`方法被触发了，生成器到达了第一个`yield`函数，然后生成器被暂停了。
2. 当触发`next('world')`后，生成器从暂停中恢复，回到`yield`指令，但这次有一个值传回到生成器。这个值会接着赋给`what`变量。然后生成器执行`console.log()`指令并停止。

同样地，可以迫使生成器抛出一个异常。可以通过生成器的`throw`方法来实现，示例如下：

```
var twoWay = twoWayGenerator();
twoWay.next();
twoWay.throw( new Error() );
```
使用上面这个代码段，当`yield`函数返回时，`twoWayGenerator()`函数将会抛出一个异常。这和生成器内部抛出异常是类似的，这种异常可以和其它异常一样，可以被`try-catch`块捕获。

## 使用generator进行异步流程控制
你一定想知道生成器会如何帮助我们来处理异步操作。下面会举个例子，创建一个函数，使我们可以在生成器内部使用异步函数，然后当异步操作完成后，恢复生成器的执行。我们将这个函数称作`asyncFlow()`：

```
function asyncFlow(generatorFunction) {
    function callback(err) {
        if (err) {
            return generator.throw(err);
        }
        var results = [].slice.call(arguments, 1);
        generator.next(results.length > 1 ? results : results[0]);
    };
    var generator = generatorFunction(callback);
    generator.next();
}
```
前面的函数接收一个生成器作为输入，实例化它，然后立刻开始执行：

```
 var results = [].slice.call(arguments, 1);
generator.next(results.length > 1 ? results : results[0]);
```
`generatorFunction()`接收一个可以发生错误时触发`generator.throw()`回调作为输入；否则的话，它会通过把回调中拿到的结果传回的方式恢复执行：

```
if (err) {
    return generator.throw(err);
}
var results = [].slice.call(arguments, 1);
generator.next(results.length > 1 ? results : results[0]);
```
为展示这个简单函数的作用，创建一个新的模块`clone.js`,其功能是创建自身的副本，把刚刚创建的`asyncFlow()`函数代码粘贴进来，并附加下面的程序核心代码：

```
var fs = require('fs');
var path = require('path');

asyncFlow(function* (callback) {
    var fileName = path.basename(__filename);
    var myself = yield fs.readFile(fileName, 'utf8', callback);
    yield fs.writeFile('clone_of_' + fileName, myself, callback);
    console.log('Clone created');
});
```
很明显，在`asyncFlow()`函数的帮助下，使我们可以用线性的方式写异步代码，就和写同步阻塞代码一样！其背后的魔法应该已经清楚了。一旦异步操作完成，传递到每个异步函数的回调将会依次恢复生成器。这一切并不复杂，但效果非常好。
这项技术有两个变种，一种是和promise一起使用，另外一种是使用*thunks*(转换程序)。

> 用在基于生成器的流程控制中的转换程序只是一个函数，它给原始函数赋了除最回调函数以外的值。返回值是一个以回到函数作为参数的函数。比如，`fs.readFile()`转换后的版本如下：
 
```
function readFileThunk(filename, options) {
  return function(callback) {
    fs.readFile(filename, options, callback);
  }
}
```
不管是转换程序还是promise都使我们可以创建生成器，无需传入回调作为参数；比如，转换程序版本的`asyncFlow()`如下：

```
function asyncFlowWithThunks(generatorFunction) {
    function callback(err) {
        if (err) {
            return generator.throw(err);
        }
        var results = [].slice.call(arguments, 1);
        var thunk = generator.next(results.length > 1 ? results : results[0]).value;
        thunk && thunk(callback);
    };
    var generator = generatorFunction();
    var thunk = generator.next().value;
    thunk && thunk(callback);
}
```
技巧在于，读取`generator.next()`的返回值，它包含转换后的方法。下一步是触发转换后的程序本身，把前面定义的特殊回调函数注入。这样我们就可以以以下方式写代码了：

```
asyncFlowWithThunks(function* () {
    var myself = yield readFileThunk(__filename, 'utf8');
    yield writeFileThunk("clone of clone.js", myself);
    console.log("Clone created");
});
```
类似地，可以实现一个版本的`asyncFlow()`，接收一个promise作为可产出对象。我把这个留作练习，其实现只需小幅修改`asyncFlowWithThunks()`函数。也可以实现一个`asyncFlow()`函数，可以接收promise和转换后的函数作为可产出对象，使用相同的原则。

### 使用co进行基于generator的流程控制
你可能已经猜到了，Node.js生态系统已经提供了一些使用生成器处理异步流程控制的解决方案。比如，`suspend`(https://npmjs.org/package/suspend )就是其中比较古老的一个，支持promise、转换器、Node.js风格的回调还有原生的回调函数。同样地，大部分前面章节提到的promise库也提供了能让promise和生成器一起使用的帮助类。

所有这些解决方案和`asyncFlow()`函数基于相同的原理；所以我们可以利用他们中的一个，而不是自己写一个。

对于这一节的例子，选用*co*（ https://npmjs.org/package/co ），它现在正流行。作为一个弹性的解决方案，`co`支持一些类型的可产出对象，比如：

* 转换器
* Promise
* 数组（并行执行）
* 对象（并行执行）
* 生成器（委托）
* 生成器函数（委托）

`co`也有其代码库的生态系统，包括如下：

* web框架，最流行的是`koa`( https://npmjs.org/package/koa )
* 实现特定流程控制模式的库
* 包装流行API，使其支持*co*的库

后面将会使用*co*来实现生成器版本的网络爬虫。

其中，为了把Node.js风格的函数转换为转换器，将会使用一个小的类库叫做*thunkify*( https://npmjs.org/package/thunkify )
## 顺序执行

## 并行执行

## 有限的并行执行

### 生产者消费者模式

### 限制下载任务的并发

