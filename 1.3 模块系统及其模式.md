# 模块系统及其模式
模块是构建大型应用的砖块，也是确保信息隐藏的主要机制，通过保持没有被标记为隐藏的方法和变量为私有来实现这一机制。这一节将要介绍Node.js的模块系统和大部分常用模式。
## 展现式模块模式
JavaScript的主要问题之一是缺少命名空间。运行在公共作用域的程序其来自内部和依赖的数据会污染它。解决这一问题的一项流行技术叫做`展现式模块模式`，常见的写法如下所示：

```
var module = (function() {
  var privateFoo = function() {...};
  var privateVar = [];

  var export = {
    publicFoo: function() {...},
    publicBar: function() {...}
  }

  return export;
})(); 
```
这个模式使用一个自动触发的函数来创建一个私有的作用域，只导出打算公开的部分。在前面的代码中，`module`变量只包含导出的接口，剩下的模块内容在外部无法完全访问。等会我们就可以看到，这种模式隐含的思想便是Node.js模块系统的基础。

## Node.js的模块系统详解
CommonJS是一个致力于标准化JavaScript生态系统的组织，他们最著名的提议之一便是`CommonJS 模块`。Node.js在这个规范的基础上构建了它的模块，同时也包含了一些自定义的拓展。为了描述它的工作机制，我们可以采用发现式模块模式来模拟它。在这种模式下，每个模块在其私有作用域下运行，这样一来，每个本地定义的变量不会污染全局命名空间。
### 自制的模块加载器
为了解释其工作机制，我们来从头构建一个类似的系统。下面的代码创建了一个函数，模拟了一部分`require()`函数的功能。
从创建一个加载模块内容、将其包装至私有作用域、并进行解析的函数开始：

```
function loadModule(filename, module, require) {
  var wrappedSrc =
    '(function(module, exports, require) {' +
      fs.readFileSync(filename, 'utf8') +
    '})(module, module.exports, require);';
  eval(wrappedSrc);
}
```
一个模块被整体包裹至一个函数，这个函数是用来实现发现式模块模式的。区别是我们向模块传入了几个变量`module`、`exports`和`require`。记住包装函数的`exports`参数是怎样被`module.exports`的内容初始化的，我们等会会讨论。
> 注：记住，这只是一个例子，你在一个实际的项目中无需解析源代码。诸如`eval()`和`[vm 模块](https://nodejs.org/api/vm.html)`非常容易误用或是包含错误的输入，这将导致系统为代码注入敞开了大门。这些特性应尽量避免使用，要用也得非常小心。

现在来通过实现我们自己的`require()`来看这些变量包含什么内容：

```
var require = function(moduleName) {
  console.log('触发引入模块: ' + moduleName);
  var id = require.resolve(moduleName);    //[1]
  if(require.cache[id]) {                  //[2]
    return require.cache[id].exports;
  }
 
  //模块元数据
  var module = {                           //[3]
    exports: {},
    id: id
  };
  //更新缓存
  require.cache[id] = module;              //[4]

  //加载模块
  loadModule(id, module, require);         //[5]
  
  //返回导出的变量
  return module.exports;                   //[6]
};
require.cache = {};
require.resolve = function(moduleName) {
  /* 通过模块名称获取模块编号 */
}
```

### 定义一个模块

### 定义全局变量

### module.exports 和 exports

### require是同步的

### 解析算法

### 模块换存

### 循环

## 模块定义模式

### 命名导出

### 导出一个函数

### 导出一个构造器

### 导出一个实例

### 修改其它模块或全局作用域



