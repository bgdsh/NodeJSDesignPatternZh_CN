# 模块系统及其模式
模块是构建大型应用的砖块，也是确保信息隐藏的主要机制，通过保持没有被标记为隐藏的方法和变量为私有来实现这一机制。这一节将要介绍Node.js的模块系统和大部分常用模式。
## 展现式模块模式
JavaScript的主要问题之一是缺少命名空间。运行在公共作用域的程序其来自内部和依赖的数据会污染它。解决这一问题的一项流行技术叫做`展现式模块模式`，常见的写法如下所示：

```
var module = (function() {
  var privateFoo = function() {...};
  var privateVar = [];

  var export = {
    publicFoo: function() {...},
    publicBar: function() {...}
  }

  return export;
})(); 
```
这个模式使用一个自动触发的函数来创建一个私有的作用域，只导出打算公开的部分。在前面的代码中，`module`变量只包含导出的接口，剩下的模块内容在外部无法完全访问。等会我们就可以看到，这种模式隐含的思想便是Node.js模块系统的基础。

## Node.js的模块系统详解
CommonJS是一个致力于标准化JavaScript生态系统的组织，他们最著名的提议之一便是`CommonJS 模块`。Node.js在这个规范的基础上构建了它的模块，同时也包含了一些自定义的拓展。为了描述它的工作机制，我们可以采用发现式模块模式来模拟它。在这种模式下，每个模块在其私有作用域下运行，这样一来，每个本地定义的变量不会污染全局命名空间。
### 自制的模块加载器
为了解释其工作机制，我们来从头构建一个类似的系统。下面的代码创建了一个函数，模拟了一部分`require()`函数的功能。
从创建一个加载模块内容、将其包装至私有作用域、并进行解析的函数开始：

```
function loadModule(filename, module, require) {
  var wrappedSrc =
    '(function(module, exports, require) {' +
      fs.readFileSync(filename, 'utf8') +
    '})(module, module.exports, require);';
  eval(wrappedSrc);
}
```
一个模块被整体包裹至一个函数，这个函数是用来实现发现式模块模式的。区别是我们向模块传入了几个变量`module`、`exports`和`require`。记住包装函数的`exports`参数是怎样被`module.exports`的内容初始化的，我们等会会讨论。
> 注：记住，这只是一个例子，你在一个实际的项目中无需解析源代码。诸如`eval()`和`[vm 模块](https://nodejs.org/api/vm.html)`非常容易误用或是包含错误的输入，这将导致系统为代码注入敞开了大门。这些特性应尽量避免使用，要用也得非常小心。

现在来通过实现我们自己的`require()`来看这些变量包含什么内容：

```
var require = function(moduleName) {
  console.log('触发引入模块: ' + moduleName);
  var id = require.resolve(moduleName);    //[1]
  if(require.cache[id]) {                  //[2]
    return require.cache[id].exports;
  }
 
  //模块元数据
  var module = {                           //[3]
    exports: {},
    id: id
  };
  //更新缓存
  require.cache[id] = module;              //[4]

  //加载模块
  loadModule(id, module, require);         //[5]
  
  //返回导出的变量
  return module.exports;                   //[6]
};
require.cache = {};
require.resolve = function(moduleName) {
  /* 通过模块名称获取模块编号 */
}
```
上面的代码模拟了Node.js原生的`require()`函数的行为，用于加载模块。当然了，这只是用作讲解原理，不能准确、完整地反映`require()`内部真正的机制，但理解Node.js的内部模块系统也是非常有意义的，比如模块是怎样定义的，怎样加载的。下述内容解释了自制模块系统：
1. 接收一个文件名作为输入，首先要做的是获取文件完整路径，这里叫做`id`。这个任务委托给了实现了特定算法的`require.resolve()`函数，函数的具体实现稍后讨论。
2. 如果模块原来已经加载过，就可以从缓存里直接获取到。这种情况下，可以立即返回。
3. 如果模块尚未加载过，我们为首次加载创造条件。我们特地创建一个`module`对象，包含一个值为空对象的`exports`属性。这个属性会被用于导出模块的公共API。
4. `module`对象被缓存起来。
5. 和前面见到过的一样，模块的代码被从文件读取出来，进行解析。我们给模块提供`module`对象，和`require()`的引用。模块通过操作或者替换`module.exports`对象来导出公共接口。
6. 最终，`module.exports`的内容，即模块的公共接口，被换回给调用者。

从上文可以看到，Node.js的模块系统背后并没有什么神奇的东西；技巧全在我们为模块代码创建的包装器和运行他们的人造环境。

### 定义一个模块
通过观察我们的自制`require()`是怎样工作的，我们应该已经知道怎样定义一个模块了。下面是一个例子：

```
//加载另外一个依赖
var dependency = require('./anotherModule');

//一个私有的方法
function log() {
  console.log('Well done ' + dependency.username);
}

//一个导出为公用的接口
module.exports.run = function() {
  log();
};
```
需要记住的一个概念是：除了和`module.exports`这个变量关联的代码之外的全部内容都是私有的。当使用`require()`加载时，这个变量的内容会被缓存、返回。
### 定义全局变量
即便在模块内部定义的所有变量都是属于本地作用域的，但也有方法来定义一个全局变量。实际上，模块系统会暴露出一个特别的变量，叫做`global`，可以用来达成这个目标。所有赋值给这个变量的内容都会属于全局作用域。
> 注：请记住，污染全局作用域是不好的实践，会减弱模块系统的优势。所以，只在必要的时候才用它。

### module.exports 和 exports
对于不熟悉Node.js的人，会对用于暴露公共API的`exports`、`module.exports`之间的差别感到疑惑。我们的自制`require()`函数应该已经解释了这个疑惑。变量`exports`只是对`module.exports`的初始值的引用；我们已经看到，它只是模块加载前的一个字面量。
这意味着我们只能新增新的属性到`exports`所引用的变量，如下代码所示：

```
exports.hello=function() {
	console.log('Hello');
}
```
重新给`exports`赋值没任何影响，因为它不会改变`module.exports`的内容，只是给这个变量重新赋值了。所以下面的代码是不对的：

```
exports=function() {
	console.log('Hello');
}
```
如果想导出的不是一个对象，比如一个函数、实例、字符串，我们只能像下面这样给`module.exports`重新赋值：

```
module.exports=function() {
	console.log('Hello');
}
```
### require是同步的
另外一个需要考虑到的问题是：我们的自制`require()`是同步的。实际上，只是用直接的方式返回模块内容，不需要回调函数。原生的`require()`也是这样。因此，给`module.exports`的赋值操作也必须是同步的。比如，下面的代码是不对的：

```
setTimeout(function() {
  module.exports = function() {...};
}, 100);
```
这个特性给定义模块带来了极大的不便，大部分情况下它限制我们定义模块的时候只能用同步代码。这也是Node.js核心库提供同步的接口而不是异步接口的原因。
如果我们需要一些异步的初始化模块的步骤，我们需要定义并导出一个未初始化的模块，这个模块过一会才会被被初始化。使用这个方法的问题是，使用`require()`加载这个模块没法保证该模块当前是可用的。在第6章，**技巧**中，我们将详细分析这个问题，我会提供一些模式来优雅地解决这个问题。
> 注：出于好奇，你可能想早点知道。Node.js早期包含一个异步版本的`require()`，但是由于太复杂、只能用于初始化阶段并且带来的麻烦多于好处被废弃了。

### 解析算法
术语`依赖地狱`，描述的就是一个软件的依赖是和软件基于同一个依赖，但是依赖的版本不同。Node.js根据模块加载位置的不同来加载不同的模块，优雅地解决了这个问题。这个特性是基于`npm`和`require()`的解析算法的。
我们先该快速概览一下这个算法。我们可以看到，`resolve()`函数接收一个文件名（我们这里称之为`moduleName`）作为输入，它返回模块的完整路径。这个地址用于加载代码，也用于唯一地标识这个模块。解析算法可以分成如下三个主要部分：

* *文件模块：* 如果`moduleName`以『/』开头，就被认为是模块的绝对路径，这个时候会返回它本身。如果以『./』开头，那么这个`moduleName`被认为是相对路径，从引入的模块开始计算。
* *核心模块：* 如果`moduleName`不是以『./』、『/』开头，算法会先在核心模块内尝试搜索。
* *包模块：* 如果找不到对应名称的核心模块，就会继续在从引入模块开始的文件夹结构的第一层`node_modules`文件夹中查找。如果这一层找不到，算法沿文件夹树继续搜索上一层的`node_modules`，直到文件系统的根目录。

对于文件或者包模块，单个的文件和文件夹都可作为`moduleName`。算法会按照如下的特定顺序匹配：

* <moduleName>.js
* <moduleName>/index.js
* 在<moduleName>/package.json的main属性中指定的文件夹/文件。

> 注：完整、正式的解析算法在[这里](https://nodejs.org/api/modules.html#modules_all_together)。

node_modules文件夹是npm用来存放每个包的依赖的地方。基于我们刚刚描述的算法，每个包都有自己的私有依赖。比如，下面的文件夹结构：


### 模块换存

### 循环

## 模块定义模式

### 命名导出

### 导出一个函数

### 导出一个构造器

### 导出一个实例

### 修改其它模块或全局作用域



