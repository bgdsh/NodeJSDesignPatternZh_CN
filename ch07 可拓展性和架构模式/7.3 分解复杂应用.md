# 分解复杂应用
到目前为止，我们主要分析了拓展立方体的X轴。我们已经学到了分发应用程序负载最简单、最快速的方式，同时提升了其可用性。在接下来的章节，将关注拓展立方体的Y轴，通过按照功能和服务**分解**应用来拓展。我们将会学到，这种技术不光可以拓展应用程序的容量，并且最重要的是（降低）其复杂性。
## 单块架构
术语**单块**可能会让我们认为这是一个没有分模块的系统，应用程序所有的服务都集成到一起，几乎到了无法区分的地步。然而，大部分情况下不是这样的。通常，单块系统拥有高度模块化的架构，并且内部模块间解耦做的非常好。
Liunx操作系统内核就是一个典型的案例，它是*单块内核*（和它的生态系统和Unix哲学正好相反）大类的一部分。Linux拥有成千上万的服务和模块，即便在系统运行过程中也可以动态地加载和卸载。然而，他们都以*内核模式*运行，这意味着他们中的任何一个失败的话，可能导致整个系统无法工作（你是否见过*内核恐慌*？）。这种方式和微内核架构正好相反，微内核模式是指只有操作系统的核心服务以内核模式运行，剩下的以用户模式运行，通常每个都有自己的进程。这种方式的主要好处是任一个服务出现问题都只会在隔离的环境中引起故障，而不是影响整个系统的稳定。

> 关于内核设计的Torvalds-Tanenbaum争论可能是计算机科学历史上最著名的*火焰争论*了，只要争论点是使用单块还是微内核设计。你可以在 https://groups.google.com/forum/#!msg/comp.os.minix/wlhw16QWltI/P8isWhZ8PJ8J 看到这个讨论的web版本（最先出现在Usenet）。

非常值得关注的是，在这30多年以来，这个原则依旧被应用在不同的环境中。现代单块应用可以比作单内核；如果他们的某个部件坏掉了，整个系统都会受到影响，用Node.js中的术语可以理解为所有的服务都是同一个代码库的一部分，运行在单个进程中（在没复制的情况下）。
下图是单块架构的一个例子：
![](../images/monolithic_architecture.png)

前图展示了典型的电子商务应用程序的架构。架构是模块化的；有两个不同的前端，一个是主库存，另一个是管理端界面。在内部，我们有一个清晰的功能分离，每个负责一个特定部分的业务逻辑：**产品**、**购物车**、**收银台**、**搜索**、**验证**、**用户**。然而，前面的架构是单块的，每个模块都是同一个代码库的一部分，作为同一个应用程序的一部分。当一个部分失败时，比如，一个未知错误，可能导致整个在线商店系统崩溃。
这种类型的架构的另一个问题是模块间的内部交互；实际情况是他们在同一个应用程序中运行，使其非常容易在模块间构建交互和耦合。例如，考虑一个产品被购买的用例；**收银台**模块需要更新**产品**对象的可访问性，如果这两个模块在同一个应用程序中，开发者非常容易获得**产品**的引用，直接更新它的可访问性。在一个单块系统中维持低耦合是非常难的，一部分原因是因为他们之间的边界不清楚或者没做合适的规范。
高度耦合通常是应用程序增长的的主要障碍之一，因为其复杂性，阻碍了它的可拓展性。事实上，错综复杂的依赖图意味着系统的每个部分都是一个牵制；需要维护产品的整个生命周期，每一个变化都需要仔细评估，因为每一部分都像积木塔的一个木块，移动或者移除一个都会导致整个塔崩塌。通常导致为了解决不断增加的复杂性而开会、制定开发步骤。
## 微服务架构
现在我们来揭示写一个大型应用最重要的模式：*防止写大型应用*。这看起来是一句废话，但是这毫无疑问是拓展软件系统的复杂度和容量的有效策略。所以什么是写大型应用程序的备选项？答案是拓展立方体的Y轴，按照服务和功能分离。思路是把应用程序分解为必要的部分，创建分离的、独立的应用。这基本上是和单块架构相反。这和Unix哲学一致，也和我们在本书开头讨论的Node.js原则一致，特别是*使每一个程序做好一件事情*。
**微服务架构**可能是这种模式可借鉴的模式，一组自我满足的服务代替了一个大型的单块系统。*微*是指服务必须足够小，但都在合理的范围内。不要误认为创建一个拥有100个不同的应用程序的架构但只提供一个web服务是一个好的选择。事实上，并没有严格的规定来说明一个服务应该多大或者多小，并不是只有尺寸影响了微服务架构的设计；而是多种因素的组合，主要是**松耦合**、**高内聚**和**集成复杂度**。
### 一个微服务架构的案例
我们现在来看之前的那个单块电子商务应用在使用了微服务架构之后是怎样的：
![](../images/mono_to_microservice.png)

从上图可以看出，电子商务应用程序的每个部件都是独立存在、自我维护的实体，运行在自己的上下文中，拥有自己的数据库。在生产中，他们都是各自独立的应用程序，暴露出一些咧的相关服务。
服务的**数据所有权**是微服务架构的一个重要的特性。这是数据库也需要分割，维护适当级别的隔离和独立性的原因。如果只使用一个独立的共享数据库，不同服务共同协作就容易的多；然而，这也会给服务带来耦合（基于数据），使拥有多个应用的优势受到损害。
连接所有节点的虚线告诉我们，为了整个系统的功能完整心，他们之间需要通信、交换信息。因为服务不共享同一个数据库，需要更多的通信来维持系统的数据一致性。比如**收银**应用需要知道关于**产品**的一些信息，如发货的价格和限制，与此同时，它需要更新存储在**产品**服务中的数据，如，收银结束后产品的可访问性控制。上图中，我们试着保持节点间通信的抽象。毫无疑问，最流行的策略是使用web服务，但我们后面会看到，这不是唯一的选择。

> 模式（微服务架构）：把一个复杂的应用通过创建一些小的、自包含的服务来分解掉。

### 微服务架构的优缺点
这一节，我们将强调实现微服务架构的优缺点。我们将会看到，这种方式将会给我们的应用开发的方式带来根本性的变化，变革我们看待可拓展性和复杂度的方式，另一方面，它也引入了不小的挑战。

> Martin Fowler 写了一篇伟大的关于微服务的文章，你可以在 http://martinfowler.com/articles/microservices.html 看到。


#### 每个服务都是可拓展的
使每个服务运行在自己的应用程序上下文中的主要的技术优势是崩溃、bug、破坏性的修改都不会传递到整个系统。目标是构建真正独立的服务，它们更小、更容易修改、甚至是**重新构建**。举个例子，如果我们电子商务应用的**收银**服务突然因为一个严重的bug崩溃了,系统剩下的部分将会像往常一样继续工作。某些功能会被影响到，比如，购买产品，但是剩余的系统都会继续工作。
并且，假设我们突然发现用来实现一个部件的数据库或者编程语言并不是一个很好的设计决定。在单块应用中，在不影响整个系统的情况下，几乎什么也做不了；相反，在微服务架构的中，我们可以更容易地重新实现整个服务，使用不同的数据库或平台，系统的其它部分甚至都觉察不到。

#### 跨平台和语言的重用
把一个大型的单块系统分解成需要小的服务，我们可以创造可以更容易重用的独立工具。**ElasticSearch**是一个可重用的搜索服务的好例子，我们在第五章*关联模块*中构建的验证服务器也是一个可以很容易地在很多应用中重用的服务的例子，除了构建它的编程语言之外。
主要优势在于，和单块应用比起来，信息隐藏级别更高了。这可能是因为交互通常是通过远程的接口发生的，比如web服务或消息，这使其更容易隐藏服务的实现和部署细节。比如，如果进需要触发一个web服务，我们无法知道背后的基础设施是怎样拓展的，使用的编程语言，使用的什么数据库等等。
#### 拓展应用的方法
回到拓展立方体，非常清楚，微服务是等价于沿着Y轴拓展应用，所以已经有了在多台机器之间分配负载的机制。同时，我们也不该忘记我们可以组合微服务，利用立方体的其它两个维度来进一步拓展应用。比如，每个服务可以被复制，以处理更多请求，并且，有趣的方面是他们都可以被独立地拓展，可以更好地进行资源管理。

#### 微服务的挑战
到现在为止，看起来微服务可以解决我们所有的问题；然而，事实远非如此。实际上，维护更多的节点在集成、部署、代码共享方面带来了更高的复杂性；它修复了传统架构的一些弊病，但也带来了许多新问题。怎样使应用交互？怎样部署、拓展、监控如此大量的应用？幸运的的，云服务和现代的DEVOPS方法论可以为这些问题提供答案，同时，Node.js可以帮大忙。它的模块系统使共享代码更方便。Node.js本来的设计就是分布式系统（就是我们使用微服务架构实现的这种）中的一个节点。

> 尽管微服务可以使用任何框架（甚至是只用核心Node.js模块）构建，但也有一些解决方案专门为此而生，他们中最有名的是**[Seneca](https://npmjs.org/package/seneca)**。管理微服务部署的一个很有用的工具是*[nscale](https://github.com/nearform/nscale)*

## 微服务架构的集成模式
### API代理
### API编排
### 和消息代理集成



