# 分解复杂应用
到目前为止，我们主要分析了拓展立方体的X轴。我们已经学到了分发应用程序负载最简单、最快速的方式，同时提升了其可用性。在接下来的章节，将关注拓展立方体的Y轴，通过按照功能和服务**分解**应用来拓展。我们将会学到，这种技术不光可以拓展应用程序的容量，并且最重要的是（降低）其复杂性。
## 单块架构
术语**单块**可能会让我们认为这是一个没有分模块的系统，应用程序所有的服务都集成到一起，几乎到了无法区分的地步。然而，大部分情况下不是这样的。通常，单块系统拥有高度模块化的架构，并且内部模块间解耦做的非常好。
Liunx操作系统内核就是一个典型的案例，它是*单块内核*（和它的生态系统和Unix哲学正好相反）大类的一部分。Linux拥有成千上万的服务和模块，即便在系统运行过程中也可以动态地加载和卸载。然而，他们都以*内核模式*运行，这意味着他们中的任何一个失败的话，可能导致整个系统无法工作（你是否见过*内核恐慌*？）。这种方式和微内核架构正好相反，微内核模式是指只有操作系统的核心服务以内核模式运行，剩下的以用户模式运行，通常每个都有自己的进程。这种方式的主要好处是任一个服务出现问题都只会在隔离的环境中引起故障，而不是影响整个系统的稳定。

> 关于内核设计的Torvalds-Tanenbaum争论可能是计算机科学历史上最著名的*火焰争论*了，只要争论点是使用单块还是微内核设计。你可以在 https://groups.google.com/forum/#!msg/comp.os.minix/wlhw16QWltI/P8isWhZ8PJ8J 看到这个讨论的web版本（最先出现在Usenet）。

非常值得关注的是，在这30多年以来，这个原则依旧被应用在不同的环境中。现代单块应用可以比作单内核；如果他们的某个部件坏掉了，整个系统都会受到影响，用Node.js中的术语可以理解为所有的服务都是同一个代码库的一部分，运行在单个进程中（在没复制的情况下）。
下图是单块架构的一个例子：
![](../images/monolithic_architecture.png)

前图展示了典型的电子商务应用程序的架构。架构是模块化的；有两个不同的前端，一个是主库存，另一个是管理端界面。在内部，我们有一个清晰的功能分离，每个负责一个特定部分的业务逻辑：**产品**、**购物车**、**收银台**、**搜索**、**验证**、**用户**。然而，前面的架构是单块的，每个模块都是同一个代码库的一部分，作为同一个应用程序的一部分。当一个部分失败时，比如，一个未知错误，可能导致整个在线商店系统崩溃。
这种类型的架构的另一个问题是模块间的内部交互；实际情况是他们在同一个应用程序中运行，使其非常容易在模块间构建交互和耦合。例如，考虑一个产品被购买的用例；**收银台**模块需要更新**产品**对象的可访问性，如果这两个模块在同一个应用程序中，开发者非常容易获得**产品**的引用，直接更新它的可访问性。在一个单块系统中维持低耦合是非常难的，一部分原因是因为他们之间的边界不清楚或者没做合适的规范。
高度耦合通常是应用程序增长的的主要障碍之一，因为其复杂性，阻碍了它的可拓展性。事实上，错综复杂的依赖图意味着系统的每个部分都是一个牵制；需要维护产品的整个生命周期，每一个变化都需要仔细评估，因为每一部分都像积木塔的一个木块，移动或者移除一个都会导致整个塔崩塌。通常导致为了解决不断增加的复杂性而开会、制定开发步骤。
## 微服务架构
现在我们来揭示写一个大型应用最重要的模式：
### 一个微服务架构的案例
### 微服务架构的优缺点
#### 每个服务都是可拓展的
#### 跨平台和语言的重用
#### 拓展应用的方法
#### 微服务的挑战
## 微服务架构的集成模式
### API代理
### API编排
### 和消息代理集成



