# 发布订阅模式
发布/订阅（通常缩写为Pub/Sub）可能是最知名的单向消息模式了。我们应该对它很熟悉了，它就是一个分布式的**观察者模式**。在观察者模式的案例中，有一组**订阅者**注册到了他们希望接收的特定类型的消息。从另一方面来将，**发布者**创建了消息，可以在相关的订阅者之间分发。下图展示了两种主要的pub/sub模式，第一个是点到点的，第二个使用了代理来协调通信：

![](../images/message_pub_sub.png)

pub/sub的特殊性在于，发布者预先不知道谁将接收消息。就像前面说到的一样，订阅者需要注册到自己希望接收的消息类型上，使发布者可以和未知数量的接收者一起工作。换句话说，pub/sub模式的两端是松耦合的，这个特性使其非常适合集成正在扩张的系统中的不同节点。
消息代理的出现进一步提升了节点间的解耦程度，因为订阅者只和代理交互，不知道哪个节点是消息的发送者。我们后面可以看到，消息代理也可以提供消息队列系统，在节点间存在连接问题时也能保证可靠传输。
现在，我们举个例子来描述这个模式：
## 构建一个简单的实时聊天应用
为了展示一个用pub/sub模式来集成分布式架构的例子，我们会构建一个基础的实时聊天应用，使用纯WebSockets。然后，我们试着通过运行多个实例来拓展它，并使用一个消息系统来使他们通信。
### 实现服务器端
现在我们立即开始吧。首先构建聊天应用；我们将依靠*ws*包（ https://npmjs.org/package/ws ）来实现,它是一个专门为Node.js实现的WebSocket。我们都知道，使用Node.js实现一个试试应用非常简单，我们的代码会印证这个说法。然后创建聊天应用的服务器端；其内容（在*app.js*文件中）如下：

```
var WebSocketServer = require('ws').Server;

//static file server
var server = require('http').createServer(   //[1]
  require('ecstatic')({root: __dirname + '/www'})
);

var wss = new WebSocketServer({server: server});     //[2]
wss.on('connection', function(ws) {
  console.log('Client connected');
  ws.on('message', function(msg) {         //[3]
    console.log('Message: ' + msg);
    broadcast(msg);
  });
});

function broadcast(msg) {           //[4]
  wss.clients.forEach(function(client) {
    client.send(msg);
  });
}

server.listen(process.argv[2] || 8080);
```
这样就行了！这是实现我们的聊天服务器需要做的所有工作。它是这样工作的：

1. 我们先创建一个http服务器，附加一个中间件叫做*ecstatic*( https://npmjs.org/package/ecstatic )来提供静态文件。应用程序给客户端提供资源（JavaScript和CSS）就需要这个。
2. 我们创建了一个WebSocket服务器的新实例然后附加到一个已有的HTTP服务器上。然后通过附加一个对*connection*事件监听器来监听进入的WebSocket连接。
3. 每次一个新的客户端连接到服务器，我们开始监听进入的消息。当消息到达后，把它光波导所有连接的客户端。
4. *broadcast()*函数简单地遍历所有相连的客户端,然后分别触发其*send()*函数。

这就是Node.js的魔法！当然了，我们实现的服务器非常小、非常基础，但我们将会看到，它可以工作。
### 实现客户端
接下来，该实现聊天功能的客户端了；这也非常小巧，只是最少量的HTML，包含一些基本的JavaScript代码。我们来创建这个叫做*www/index.html*的文件表示的页面：

```
<html>
  <head>
    <script>
      var ws = new WebSocket('ws://' + window.document.location.host);
      ws.onmessage = function(message) {
        var msgDiv = document.createElement('div');
        msgDiv.innerHTML = message.data;
        document.getElementById('messages').appendChild(msgDiv);
      };
      
      function sendMessage() {
        var message = document.getElementById('msgBox').value;
        ws.send(message);
      }
    </script>
  </head>
  <body>
    Messages:
    <div id='messages'></div>
    <input type='text' placeholder='Send a message' id='msgBox'>
    <input type='button' onclick='sendMessage()' value='Send'>
  </body>
</html> 
```
我们创建的HTML页面都不需要任何的注释；只是一段简单的web开发代码。使用原生的WebSocket对象来初始化到Node.js服务器的连接，然后开始监听从服务器来的消息，当消息到达时，把他们展示在一个新建的*div*标签中。为了发送消息，使用一个简单的文本框和按钮。

> 当结束或者重启一个聊天服务器，WebSocket连接结束并且不会重新连接（应该使用*Socket.io*这种高级库）。这意味着服务器重启后需要刷新浏览器来重建连接（或者重新实现一个重连机制，这里不会详述）。

### 运行和拓展聊天应用
我们可以立刻试着运行我们的应用，使用如下命令启动服务器：

```
node app 8080
```
> 你需要有一个版本比较新的支持WebSocket的浏览器才能运行这个Demo，下面是兼容的浏览器： http://caniuse.com/#feat=websockets

在浏览器打开*http://localhost:8080*,将看到如下图所示的界面：

![](../images/message_webscoket_demo.png)
我们现在想要展示的是，当我们试着通过启动多个实例来拓展应用。让我们试着这样做，在另一个端口上启动另一个服务器：

```
node app 8081
```
我们希望结果是两个客户端连接到两个不同的服务器，可以交换聊天信息。但遗憾的是，我们现在的代码无法实现这个功能，可以通过打开*http://localhost:8081* 试试。
我们在一个实例上发送一个聊天消息，只能在本地广播，在连接到特定服务器的客户端之间分发消息。两个服务器之间不能交流。我们需要集成他们。

> 在实际应用中，我们使用负载均衡器来在实例间分发流量，但在这个demo中不用。这就使我们可以特意访问每个服务器来看实例间是怎样交互的。

## 使用Redis作为消息代理
## 用øMQ实现点到点的发布订阅
### øMQ介绍
### 为聊天服务器设计一个点到点的架构
### 使用ZMQ的PUB/SUB插口
## 持久的订阅者
### AMQP简介
### 使用AMQP和RabbitMQ实现持久订阅
#### 为聊天应用设计一个历史服务
#### 使用AMQP实现一个可靠的历史服务
#### 使用AMQP集成聊天应用





