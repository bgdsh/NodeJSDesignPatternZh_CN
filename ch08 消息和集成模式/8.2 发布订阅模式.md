# 发布订阅模式
发布/订阅（通常缩写为Pub/Sub）可能是最知名的单向消息模式了。我们应该对它很熟悉了，它就是一个分布式的**观察者模式**。在观察者模式的案例中，有一组**订阅者**注册到了他们希望接收的特定类型的消息。从另一方面来将，**发布者**创建了消息，可以在相关的订阅者之间分发。下图展示了两种主要的pub/sub模式，第一个是点到点的，第二个使用了代理来协调通信：

![](../images/message_pub_sub.png)

pub/sub的特殊性在于，发布者预先不知道谁将接收消息。就像前面说到的一样，订阅者需要注册到自己希望接收的消息类型上，使发布者可以和未知数量的接收者一起工作。换句话说，pub/sub模式的两端是松耦合的，这个特性使其非常适合集成正在扩张的系统中的不同节点。
消息代理的出现进一步提升了节点间的解耦程度，因为订阅者只和代理交互，不知道哪个节点是消息的发送者。我们后面可以看到，消息代理也可以提供消息队列系统，在节点间存在连接问题时也能保证可靠传输。
现在，我们举个例子来描述这个模式：
## 构建一个简单的实时聊天应用
为了展示一个用pub/sub模式来集成分布式架构的例子，我们会构建一个基础的实时聊天应用，使用纯WebSockets。然后，我们试着通过运行多个实例来拓展它，并使用一个消息系统来使他们通信。
### 实现服务器端
现在我们立即开始吧。首先构建聊天应用；我们将依靠*ws*包（ https://npmjs.org/package/ws ）来实现,它是一个专门为Node.js实现的WebSocket。我们都知道，使用Node.js实现一个试试应用非常简单，我们的代码会印证这个说法。然后创建聊天应用的服务器端；其内容（在*app.js*文件中）如下：

```
var WebSocketServer = require('ws').Server;

//static file server
var server = require('http').createServer(   //[1]
  require('ecstatic')({root: __dirname + '/www'})
);

var wss = new WebSocketServer({server: server});     //[2]
wss.on('connection', function(ws) {
  console.log('Client connected');
  ws.on('message', function(msg) {         //[3]
    console.log('Message: ' + msg);
    broadcast(msg);
  });
});

function broadcast(msg) {           //[4]
  wss.clients.forEach(function(client) {
    client.send(msg);
  });
}

server.listen(process.argv[2] || 8080);
```
这样就行了！这是实现我们的聊天服务器需要做的所有工作。它是这样工作的：

1. 我们先创建一个http服务器，附加一个中间件叫做*ecstatic*( https://npmjs.org/package/ecstatic )来提供静态文件。应用程序给客户端提供资源（JavaScript和CSS）就需要这个。
2. 我们创建了一个WebSocket服务器的新实例然后附加到一个已有的HTTP服务器上。然后通过附加一个对*connection*事件监听器来监听进入的WebSocket连接。
3. 每次一个新的客户端连接到服务器，我们开始监听进入的消息。当消息到达后，把它光波导所有连接的客户端。
4. *broadcast()*函数简单地遍历所有相连的客户端,然后分别触发其*send()*函数。

这就是Node.js的魔法！当然了，我们实现的服务器非常小、非常基础，但我们将会看到，它可以工作。
### 实现客户端
接下来，该实现聊天功能的客户端了；这也非常小巧，只是最少量的HTML，包含一些基本的JavaScript代码。我们来创建这个叫做*www/index.html*的文件表示的页面：

```
<html>
  <head>
    <script>
      var ws = new WebSocket('ws://' + window.document.location.host);
      ws.onmessage = function(message) {
        var msgDiv = document.createElement('div');
        msgDiv.innerHTML = message.data;
        document.getElementById('messages').appendChild(msgDiv);
      };
      
      function sendMessage() {
        var message = document.getElementById('msgBox').value;
        ws.send(message);
      }
    </script>
  </head>
  <body>
    Messages:
    <div id='messages'></div>
    <input type='text' placeholder='Send a message' id='msgBox'>
    <input type='button' onclick='sendMessage()' value='Send'>
  </body>
</html> 
```
我们创建的HTML页面都不需要任何的注释；只是一段简单的web开发代码。使用原生的WebSocket对象来初始化到Node.js服务器的连接，然后开始监听从服务器来的消息，当消息到达时，把他们展示在一个新建的*div*标签中。为了发送消息，使用一个简单的文本框和按钮。

> 当结束或者重启一个聊天服务器，WebSocket连接结束并且不会重新连接（应该使用*Socket.io*这种高级库）。这意味着服务器重启后需要刷新浏览器来重建连接（或者重新实现一个重连机制，这里不会详述）。

### 运行和拓展聊天应用
我们可以立刻试着运行我们的应用，使用如下命令启动服务器：

```
node app 8080
```
> 你需要有一个版本比较新的支持WebSocket的浏览器才能运行这个Demo，下面是兼容的浏览器： http://caniuse.com/#feat=websockets

在浏览器打开*http://localhost:8080*,将看到如下图所示的界面：

![](../images/message_webscoket_demo.png)
我们现在想要展示的是，当我们试着通过启动多个实例来拓展应用。让我们试着这样做，在另一个端口上启动另一个服务器：

```
node app 8081
```
我们希望结果是两个客户端连接到两个不同的服务器，可以交换聊天信息。但遗憾的是，我们现在的代码无法实现这个功能，可以通过打开*http://localhost:8081* 试试。
我们在一个实例上发送一个聊天消息，只能在本地广播，在连接到特定服务器的客户端之间分发消息。两个服务器之间不能交流。我们需要集成他们。

> 在实际应用中，我们使用负载均衡器来在实例间分发流量，但在这个demo中不用。这就使我们可以特意访问每个服务器来看实例间是怎样交互的。

## 使用Redis作为消息代理
我们以Redis( http://redis.io )为开端，分析最重要的pub/sub实现，Redis是一个快速、弹性的键值存储，也被很多人定义为数据结构服务器。Redis更像是一个数据库而非消息代理，然而，在它的诸多特性中间，有一组命令专门用来实现一个中心化的发布/订阅模式。当然了，和专门的高级消息中间件比起来，这个实现非常简单、基础，但这也是它流行的原因。通常，Redis已经存在于基础设施中了，比如作为一个缓存服务器或者存储会话信息；它的速度和可拓展性使其非常适合于在分布式系统中共享数据。所以，一旦在项目中需要使用发布/订阅代理，最简单迅速的选择是重用Redis本身，避免安装、维护一个专门的消息代理。让我们写一个例子来展示其简单、强大。

> 这个例子需要有一个已经安装好并能正常运行的Redis,在它的默认端口上监听。在 http://redis.io/topics/quickstart 可以看到更多细节。

我们的计划是用Redis作为一个消息代理来集成聊天服务器。每个实例把从客户端接收到的消息发布到代理上，与此同时，订阅从其它服务器实例上发来的任何消息。这样一来，我们架构中的每一个服务器都既是订阅者也是发布者。下图展示了我们想要获得的架构：

![](../images/message_use_redis.png)

通过看上图，我们可以总结出一条消息经过的历程：

1. 消息被输入到网页的文本框，然后被发送到连接的聊天服务器实例。
2. 消息然后被发布到代理。
3. 代理把消息分发给所有的订阅者，在我们的架构中，都是聊天服务器的实例。
4. 在每个实例中，消息被分发到所有连接的客户端。

> Redis允许发布和订阅一个**频道**，用一个字符串来标识，比如*chat.nodejs*。也可以使用通配符来定义订阅关系，可能匹配多个频道，比如*chat.**。

让我们来看它是怎样工作的。修改服务器端代码，增加发布/订阅逻辑：

```
var WebSocketServer = require('ws').Server;
**var redis = require("redis");**           //[1]
**var redisSub = redis.createClient();**
**var redisPub = redis.createClient();**

//static file server
var server = require('http').createServer(
  require('ecstatic')({root: __dirname + '/www'})
);

var wss = new WebSocketServer({server: server});
wss.on('connection', function(ws) {
  console.log('Client connected');
  ws.on('message', function(msg) {
    console.log('Message: ' + msg);
    **redisPub.publish('chat_messages', msg);**   //[2]
  });
});

**redisSub.subscribe('chat_messages');**     //[3]
**redisSub.on('message', function(channel, msg)** {
  wss.clients.forEach(function(client) {
    client.send(msg);
  });
});

server.listen(process.argv[2] || 8080); 
```
我们对前面代码的修改已经高亮显示了；这是它的工作模式：

1. 把我们的应用连接到Redis服务器上，使用*redis*包（ https://npmjs.org/package/redis ），它是一个完整的客户端，支持所有可用的Redis命令。然后，我们建立两个不同的链接，一个用于订阅到频道，另一个用来发布消息。这在Redis中是非常必要的，因为一旦连接被置于订阅者模式，只有订阅相关的命令可用。这样我们就需要另外一个连接来发布消息。
2. 当从一个连接的客户端收到一条消息，我们把消息发送到*chat_messages*频道。我们不直接把消息广播到客户端是因为服务器订阅到了相同的频道（等会会看到），所以它会通过Redis返回给我们。对于这个例子来说，这是简单有效的机制。
3. 刚才说到，我们的服务同时订阅到了*chat_message*频道，所以我们注册一个监听器来接收发送到这个频道的所有消息（消息可能是从当前服务器发出的，也可能是从别的服务器发出）。当接收到消息后，简单地把消息广播到所有连接到这台WebSocket服务器的客户端。

这些小修改足以集成所有我们打算启动的聊天服务器。为了证明它，我们可以试着启动应用的多个实例：

```
node app 8080
node app 8081
node app 8082
```
然后每个浏览器标签打开一个地址，验证我们发到一个服务器上的消息成功地被其它连接到别的服务器上的客户端接收到。恭喜，我们刚刚使用发布/订阅模式集成了一个实时的分布式应用。

## 用øMQ实现点到点的发布订阅
代理的存在可以在很大程度上简化消息系统的架构；然而，有时候这并不是一个可行的解决方案，比如，当延迟非常关键，当拓展复杂的分布式系统，或不允许存在存在单点失败时。
### øMQ介绍
如果我们的项目到了评估可用的点到点消息交换的备选方案时，最好的值得考虑的解决方案是**øMQ**（ http://zeromq.org ，也被称作zmq,ZeroMQ或0MQ ）；在本书的前面章节已经提到过这个库了。øMQ是一个提供了构建多种消息模式的基础工具。它是一个底层的，非常快速，使用极少的API但提供了消息系统的所有基本构建块，比如原子消息、负载均衡、队列以及更多。它支持多种类型的传输，诸如进程内频道（ inproc:// ）,进程间通信（ ipc:// ）,使用PGM协议的多发布（ pgm:// 或 epgm:// ），当然了，也支持经典的TCP（tcp://）。
在øMQ的特性中，我们可以发现用来实现发布/订阅模式的工具，正是我们的例子所需的。所以，我们现在将要做的是，把代理（Redis）从我们的聊天应用架构中移除，让多个节点借助øMQ的发布/订阅接口以点到点的模式通信。

> øMQ接口可以看做是网络接口的封装，为了方便实现最常见的消息模式，提供了进一步的抽象。比如，我们找到对应的接口来实现发布/订阅，请求/回复，或者单向通信。

### 为聊天服务器设计一个点到点的架构
当我们从架构中移除代理后，聊天应用的每个实例都需要直接连接到其它可用的实例，用于接收到他们发布的消息。在øMQ中，我们有两种为这个目的专门设计的接口：*PUB*和*SUB*。典型的模式是把*PUB*接口绑定到其它*SUB*接口订阅监听的端口上。
订阅可以有一个过滤器来确定哪种消息会被传出到*SUB*接口。过滤器是一个简单的字节流（也可以是一个字符串），将会和消息（也是一个字节流）的开头一致。当消息通过*PUB*发布，它会被广播到所有连接的*SUB*接口，但这发生在订阅过滤生效之后。只有当使用了连接协议（如TCP）后，过滤器才可以应用到发布者一侧。
下图展示了应用到分布式聊天服务器的模式（为了简便起见，只有两个实例）：

![](../images/message_p2p.png)

上图展示了当存在两个聊天服务器的实例时，信息是如何流动的，但同样的概念可以被应用于N个实例。这个架构告诉我们每个节点都需要知道系统中其它节点的情况，能够建立起所有必要的连接。这幅图同时告诉我们当信息反向流动时，订阅是怎样从*SUB*接口到*PUB*接口的。

> 为了运行本节的例子，需要在系统上安装øMQ字节文件。你可以在 http://zeromq.org/intro:get-the-software 上找到更多信息。注：这个例子是基于øMQ4.0版本测试的。

### 使用ZMQ的PUB/SUB连接


```
[...]
var args = require('minimist')(process.argv.slice(2));   //[1]
var zmq = require('zmq');

var pubSocket = zmq.socket('pub');         //[2]
pubSocket.bind('tcp://127.0.0.1:' + args['pub']);

var subSocket = zmq.socket('sub');         //[3]
var subPorts = [].concat(args['sub']);
subPorts.forEach(function(p) {
  console.log('Subscribing to ' + p);
  subSocket.connect('tcp://127.0.0.1:' + p);
});
subSocket.subscribe('chat');

[...]
  ws.on('message', function(msg) {         //[4]
    console.log('Message: ' + msg);
    broadcast(msg);
    pubSocket.send('chat ' + msg);
  });
[...]

subSocket.on('message', function(msg) {       //[5]
  console.log('From other server: ' + msg);
  broadcast(msg.toString().split(' ')[1]);
});

[...]
server.listen(args['http'] || 8080); 
```

通过上面的代码可以看出，我们的应用逻辑变得稍微复杂了一点，但还是可以直接看出我们正在实现一个分布式的点到点发布/订阅模式。让我们一起看所有的部分是怎样组合起来的：

1. 我们引用了一个*zmq*包（ https://npmjs.org/package/zmq ），它是Node.js和øMQ原生库的关联。我们也引入了*minimist*（ https://npmjs.org/package/minimist ），这是一个命令行参数解析器；使用它，可以很容易地命名的参数。
2. 立刻创建我们的*PUB*接口，把它绑定到通过*--port*命令行参数提供的端口上。
3. 我们创建*SUB*接口，把它连接到其它实例的*PUB*接口。目标*PUB*接口的端口号是通过*--sub*参数（可能多于一个）提供的。然后创建准确的订阅，通过提供*chat*作为过滤器，这意味着我们将只会收到以*chat*开头的消息。
4. 当一个新的消息通过WebSocket接收后，把它广播到所有连接到这台服务器的客户端，但同时通过*PUB*接口把它发布出去。我们使用*chat*和一个空格作为前缀，所以所有的消息都会使用*chat*作为过滤器发布到所有的订阅。
5. 我们开始监听到达*SUB*接口的消息，做一些简单的消息解析，移除前面的*chat*前缀，然后把它广播到所有的和在台服务器连接的客户端。

现在，我们构建了一个简单的分布式系统，使用点到点的发布/订阅模式把他们集成起来。
让它们开始工作，启动三个应用实例，确保他们连接到了正确的*PUB*和*SUB*接口：

```
node app --http 8080 --pub 5000 --sub 5001 --sub 5002
node app --http 8081 --pub 5001 --sub 5000 --sub 5002
node app --http 8082 --pub 5002 --sub 5000 --sub 5001
```

第一个命令要启动一个包含一个监听8080端口的HTTP服务器的实例，在端口*5000*上绑定一个*PUB*接口，在*5001*和*5002*上连接到*SUB*接口，这两个端口正是另外两个实例的*PUB*绑定的端口。另外两个命令执行类似的工作。
首先可以看到，øMQ在*PUB*对应端口不可用时不会报错。比如，在执行第一条命令时，没有实例监听端口*5001*和*5002*，但øMQ不会报任何错误。这是因为øMQ有一个重连机制，在合适的时间间隔内，会自动尝试重新建立到这些端口的连接。这个特性在某个节点宕机或者重启时也会变得非常有用。同样的*容错机制*也被应用到了*PUB*接口：如果没有订阅者，会简单地丢弃所有的消息，但它会继续运行。
此时，我们可以尝试使用浏览器导航到我们启动的任何的服务器实例，验证消息是否正确地广播到了所有的聊天服务器。

> 在前面的例子中，我们假设了一种*静态*架构，即预先知道实例的数量和他们的地址。我们可以引入一个服务注册器，就像在前面章节描述的那样，动态地连接我们的实例。同样需要指出，øMQ可以使用和刚描述的相同的指令来实现一个消息代理。

## 持久的订阅者

### AMQP简介

### 使用AMQP和RabbitMQ实现持久订阅

#### 为聊天应用设计一个历史服务

#### 使用AMQP实现一个可靠的历史服务

#### 使用AMQP集成聊天应用






